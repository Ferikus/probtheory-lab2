# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'rvmodeling.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets
import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from scipy.stats import chi2

import src.device as device
from src.stat_properties import *
from src.result_windows import *


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.setFixedSize(800, 600)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setPointSize(10)
        MainWindow.setFont(font)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(40, 140, 721, 71))
        self.label.setWordWrap(True)
        self.label.setObjectName("label")
        self.label_title = QtWidgets.QLabel(self.centralwidget)
        self.label_title.setEnabled(True)
        self.label_title.setGeometry(QtCore.QRect(130, 30, 541, 71))
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_title.setFont(font)
        self.label_title.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.label_title.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.label_title.setFrameShadow(QtWidgets.QFrame.Plain)
        self.label_title.setTextFormat(QtCore.Qt.AutoText)
        self.label_title.setAlignment(QtCore.Qt.AlignCenter)
        self.label_title.setObjectName("label_title")
        self.label_formula = QtWidgets.QLabel(self.centralwidget)
        self.label_formula.setGeometry(QtCore.QRect(40, 230, 501, 16))
        self.label_formula.setObjectName("label_formula")
        self.label_var = QtWidgets.QLabel(self.centralwidget)
        self.label_var.setGeometry(QtCore.QRect(40, 120, 81, 16))
        font = QtGui.QFont()
        font.setBold(True)
        font.setWeight(75)
        self.label_var.setFont(font)
        self.label_var.setObjectName("label_var")
        self.paramBox = QtWidgets.QGroupBox(self.centralwidget)
        self.paramBox.setGeometry(QtCore.QRect(30, 270, 731, 101))
        self.paramBox.setObjectName("paramBox")
        self.label_experiments_count = QtWidgets.QLabel(self.paramBox)
        self.label_experiments_count.setGeometry(QtCore.QRect(380, 60, 161, 16))
        self.label_experiments_count.setObjectName("label_experiments_count")
        self.label_variance = QtWidgets.QLabel(self.paramBox)
        self.label_variance.setGeometry(QtCore.QRect(60, 60, 81, 16))
        self.label_variance.setObjectName("label_variance")
        self.label_subdevice_count = QtWidgets.QLabel(self.paramBox)
        self.label_subdevice_count.setGeometry(QtCore.QRect(380, 30, 131, 16))
        self.label_subdevice_count.setObjectName("label_subdevice_count")
        self.label_mean = QtWidgets.QLabel(self.paramBox)
        self.label_mean.setGeometry(QtCore.QRect(60, 30, 71, 16))
        self.label_mean.setObjectName("label_mean")
        self.lineEdit_mean = QtWidgets.QLineEdit(self.paramBox)
        self.lineEdit_mean.setGeometry(QtCore.QRect(160, 30, 113, 20))
        self.lineEdit_mean.setObjectName("lineEdit_mean")
        self.lineEdit_variance = QtWidgets.QLineEdit(self.paramBox)
        self.lineEdit_variance.setGeometry(QtCore.QRect(160, 60, 113, 20))
        self.lineEdit_variance.setObjectName("lineEdit_variance")
        self.lineEdit_subdevice_count = QtWidgets.QLineEdit(self.paramBox)
        self.lineEdit_subdevice_count.setGeometry(QtCore.QRect(560, 30, 113, 20))
        self.lineEdit_subdevice_count.setObjectName("lineEdit_subdevice_count")
        self.lineEdit_experiments_count = QtWidgets.QLineEdit(self.paramBox)
        self.lineEdit_experiments_count.setGeometry(QtCore.QRect(560, 60, 113, 20))
        self.lineEdit_experiments_count.setObjectName("lineEdit_experiments_count")
        self.btn_1 = QtWidgets.QPushButton(self.centralwidget)
        self.btn_1.setGeometry(QtCore.QRect(170, 410, 451, 41))
        self.btn_1.setObjectName("btn_1")
        self.btn_2_1 = QtWidgets.QPushButton(self.centralwidget)
        self.btn_2_1.setGeometry(QtCore.QRect(170, 460, 241, 41))
        self.btn_2_1.setObjectName("btn_2_1")
        self.btn_2_2 = QtWidgets.QPushButton(self.centralwidget)
        self.btn_2_2.setGeometry(QtCore.QRect(420, 460, 201, 41))
        self.btn_2_2.setObjectName("btn_2_2")
        self.btn_3 = QtWidgets.QPushButton(self.centralwidget)
        self.btn_3.setGeometry(QtCore.QRect(170, 510, 451, 41))
        self.btn_3.setObjectName("btn_3")
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # обработка событий
        self.btn_1.clicked.connect(self.n1_simulate_random_variables)
        self.btn_2_1.clicked.connect(self.n2_statistical_properties)
        self.btn_2_2.clicked.connect(self.n2_intervals_table)
        self.btn_3.clicked.connect(self.n3_hypothesis_testing)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Теория вероятности. Л/Р №2."))
        self.label.setText(_translate("MainWindow",
                                      "Устройство состоит из N>>1 дублирующих приборов. "
                                      "Каждый следующий прибор включается после выхода из строя предыдущего. "
                                      "Время безотказной работы каждого прибора — положительная с.в. "
                                      "со средним Q и дисперсией R. Плотность распределения выбрать "
                                      "по аналогии с приведёнными на рисунках на с. 15. С.в. η — время "
                                      "безотказной работы всего устройства."))
        self.label_title.setText(_translate("MainWindow", "Лабораторная работа №2.\n"
                                                          "Моделирование случайных величин\n"
                                                          "и проверка гипотез о виде распределения."))
        self.label_formula.setText(_translate("MainWindow", "Функция плотности прибора — экспоненциальная."))
        self.label_var.setText(_translate("MainWindow", "Вариант 18"))
        self.paramBox.setTitle(_translate("MainWindow", "Ввод параметров"))
        self.label_experiments_count.setText(_translate("MainWindow", "Количество экспериментов"))
        self.label_variance.setText(_translate("MainWindow", "Дисперсия R"))
        self.label_subdevice_count.setText(_translate("MainWindow", "Количество приборов N"))
        self.label_mean.setText(_translate("MainWindow", "Среднее Q"))
        self.btn_1.setText(_translate("MainWindow", "1. Моделирование случайных величин"))
        self.btn_2_1.setText(_translate("MainWindow", "2.1. Статистические характеристики"))
        self.btn_2_2.setText(_translate("MainWindow", "2.2. Таблица промежутков"))
        self.btn_3.setText(_translate("MainWindow", "3. Проверка гипотезы о виде распределения"))

        self.lineEdit_mean.setText("4")
        self.lineEdit_variance.setText("1")
        self.lineEdit_subdevice_count.setText("5")
        self.lineEdit_experiments_count.setText("5")

    def n1_simulate_random_variables(self):
        try:
            subdevice_count = int(self.lineEdit_subdevice_count.text())
            expected = float(self.lineEdit_mean.text())
            variance = float(self.lineEdit_variance.text())
            experiments_count = int(self.lineEdit_experiments_count.text())

            device_instance = device.Device(subdevice_count, expected, variance)

            results = device_instance.random_draw(experiments_count)
            self.result_window = ResultWindowN1(results)
            self.result_window.show()

        except Exception as e:
            QtWidgets.QMessageBox.critical(None, "Ошибка", str(e))

    def n2_statistical_properties(self):
        try:
            sub_device_count = int(self.lineEdit_subdevice_count.text())
            expected = float(self.lineEdit_mean.text())
            variance = float(self.lineEdit_variance.text())
            experiments_count = int(self.lineEdit_experiments_count.text())

            device_instance = device.Device(sub_device_count, expected, variance)
            draw = device_instance.random_draw(experiments_count)

            # --- Вычисление характеристик ---

            mean_sample = get_mean_sample(draw)
            variance_sample = get_variance_sample(draw)
            median = get_median(draw)
            range_val = get_range_val(draw)

            mean_theoretical = device_instance.get_mean()
            variance_theoretical = device_instance.get_variance()
            std_dev_theoretical = variance_theoretical ** 0.5

            # --- Графики и расхождение D ---

            # Выборочная функция распределения Fn^
            extension = 5.
            x_values_sample = [0.] + draw
            y_values_sample = [sum(1 for r in draw if r <= x) / len(draw) for x in x_values_sample]
            x_values_sample.append(draw[-1] + extension)
            y_values_sample.append(1.0)

            # Теоретическая функция распределения Fn
            # x_theoretical = np.linspace(min(draw), max(draw), 100)
            x_theoretical = np.linspace(draw[0] - extension, max(draw) + extension, 100)
            y_theoretical = norm.cdf(x_theoretical, loc=mean_theoretical, scale=std_dev_theoretical)

            plt.figure(figsize=(8, 6))
            plt.step(x_values_sample, y_values_sample, where='post', label='Выборочная функция')
            plt.plot(x_theoretical, y_theoretical, label='Теоретическая функция')
            plt.xlim(draw[0] - extension, draw[-1] + extension)
            plt.ylim(-0.05, 1.05)
            plt.xlabel('Значение x')
            plt.ylabel('Вероятность P')
            plt.title('Функции распределения')
            plt.grid(True)

            # Расхождение D (по теореме Гливенко-Кантелли)
            y_values_theoretical = norm.cdf(x_values_sample, loc=mean_theoretical, scale=std_dev_theoretical)
            d = max(abs(y_t - y_s) for y_t, y_s in zip(y_values_theoretical, y_values_sample))

            # --- Создание словаря характеристик ---
            characteristics = {
                "Eη": mean_theoretical,                                     # теоретическое среднее
                "x_": mean_sample,                                          # выборочное среднее
                "S^2": variance_sample,                                     # выборочная дисперсия
                "|Eη - x|": abs(mean_theoretical - mean_sample),            # отклонение от среднего
                "Dη": variance_theoretical,                                 # теоретическая дисперсия
                "|Dη - S^2|": abs(variance_theoretical - variance_sample),  # отклонение от дисперсии
                "Me": median,                                               # медиана
                "R": range_val,                                             # размах
            }

            # --- Создание и отображение таблицы результатов ---
            self.result_window = ResultWindowN2(draw, characteristics, d)
            self.result_window.show()

            plt.show()

        except Exception as e:
            QtWidgets.QMessageBox.critical(None, "Ошибка", str(e))

    def n2_intervals_table(self):
        try:
            # --- Get necessary parameters from GUI ---
            sub_device_count = int(self.lineEdit_subdevice_count.text())
            expected = float(self.lineEdit_mean.text())
            variance = float(self.lineEdit_variance.text())
            experiments_count = int(self.lineEdit_experiments_count.text())

            device_instance = device.Device(sub_device_count, expected, variance)
            draw = device_instance.random_draw(experiments_count)
            mean_theoretical = device_instance.get_mean()
            variance_theoretical = device_instance.get_variance()
            std_dev_theoretical = variance_theoretical ** 0.5

            # Ввод количества интервалов
            k, ok = QtWidgets.QInputDialog.getInt(MainWindow, "Ввод интервалов", f"Введите количество интервалов:")
            if not ok:
                raise ValueError("Ввод интервалов отменен.")

            interval_bounds = [0.]
            # interval_bounds = []

            # Ввод интервалов пользователем
            # for i in range(k):
            #     bound, ok = QtWidgets.QInputDialog.getDouble(MainWindow, "Ввод интервалов", f"Введите границу интервала {i}:")
            #     if not ok:
            #         raise ValueError("Ввод интервалов отменен.")
            #     interval_bounds.append(bound)

            # Автоматическое заполнение равномерными интервалами
            interval_len = (draw[-1] - draw[0]) / k
            for i in range(k):
                interval_bounds.append(draw[0] + i * interval_len)

            z_values = []
            heights = []
            theoretical_densities = []

            for j in range(k):
                n = sum(1 for x in draw if interval_bounds[j] <= x < interval_bounds[j + 1])
                height = n / (experiments_count * (interval_bounds[j + 1] - interval_bounds[j]))
                heights.append(height)

                z = (interval_bounds[j] + interval_bounds[j + 1]) / 2
                z_values.append(z)
                theoretical_density = norm.pdf(z, loc=mean_theoretical, scale=std_dev_theoretical)
                theoretical_densities.append(theoretical_density)

            max_height = max(heights)

            # --- Словарь для таблицы ---
            table_info = {
                "z_k": z_values,                    # средняя точка интервала z
                "f_η(z_k)": theoretical_densities,  # значение ф-ции плотности в точке z
                "n_k / (n * delta'_k )": heights,   # высота прямоугольника гистограммы
            }

            self.result_window = ResultWindowN2_2(table_info, interval_bounds, max_height)
            self.result_window.show()

            # --- Гистограмма ---
            plt.figure(figsize=(8, 6))
            plt.bar(interval_bounds[1:], heights, width=interval_len, align='center', edgecolor='black')
            plt.xlabel('Значение x')
            plt.ylabel('Плотность вероятности fη')
            plt.title('Гистограмма распределения')
            plt.grid(True)
            plt.show()

        except Exception as e:
            QtWidgets.QMessageBox.critical(None, "Ошибка", str(e))

    def n3_hypothesis_testing(self):
        try:
            sub_device_count = int(self.lineEdit_subdevice_count.text())
            expected = float(self.lineEdit_mean.text())
            variance = float(self.lineEdit_variance.text())
            experiments_count = int(self.lineEdit_experiments_count.text())

            device_instance = device.Device(sub_device_count, expected, variance)
            draw = device_instance.random_draw(experiments_count)

            mean_theoretical = device_instance.get_mean()
            variance_theoretical = device_instance.get_variance()
            std_dev_theoretical = variance_theoretical ** 0.5

            k, ok = QtWidgets.QInputDialog.getInt(MainWindow, "Ввод интервалов", f"Введите количество интервалов:")
            if not ok:
                raise ValueError("Ввод интервалов отменен.")

            interval_bounds = [0.]
            interval_len = (draw[-1] - draw[0]) / k
            for i in range(k):
                interval_bounds.append(draw[0] + i * interval_len)

            n_values = []
            q_values = []

            for j in range(k):
                n = sum(1 for x in draw if interval_bounds[j] <= x < interval_bounds[j + 1])
                n_values.append(n)

                q = norm.cdf(interval_bounds[j + 1], loc=mean_theoretical, scale=std_dev_theoretical) - \
                    norm.cdf(interval_bounds[j], loc=mean_theoretical, scale=std_dev_theoretical)
                q_values.append(q)

            alpha, ok = QtWidgets.QInputDialog.getDouble(MainWindow, "Ввод уровня значимости",
                                                         "Введите уровень значимости (alpha):", 0.05, 0.01, 0.99, 2)
            if not ok:
                raise ValueError("Ввод уровня значимости отменен.")

            chi2_critical = chi2.isf(alpha, k - 1)

            r0 = sum([(n_values[j] - experiments_count * q_values[j]) ** 2 / (experiments_count * q_values[j]) for j in
                      range(k)])
            decision = "Гипотеза H0 принимается" if r0 < chi2_critical else "Гипотеза H0 отклоняется"

            self.result_window = ResultWindowN3(r0, chi2_critical, k - 1, alpha, decision)
            self.result_window.show()

        except Exception as e:
            QtWidgets.QMessageBox.critical(None, "Ошибка", str(e))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
